= Build Options
:navtitle: Build Options

This section covers a number of build scenarios that you may come across if your project has specific, legacy, or non-standard, components or processes.

== Build Individual Libraries

If you only need specific libraries and want to avoid building the entire Boost library suite, which can be time-consuming, then use the `--with-` parameter with the `b2` command to specify the individual libraries that you want to build. For example, to build the boost:thread[] library:

[source,bash]
----
b2 --with-thread
----

Note:: Some libraries are header-only, meaning they do not need to be built before use. Examples include boost:asio[], boost:bind[], boost:function[], and boost:lambda[]. You don't need to use `--with-` for these libraries since they're included directly in your source code and don't need to be pre-compiled.

To build multiple libraries, say boost:thread[] and boost:filesystem[], simply repeat the parameter:

[source,bash]
----
b2 --with-thread --with-filesystem --with-system
----

The reason why we need `--with-system` is that it is a dependency of boost:filesystem[]. 

You might need to build some dependencies even if the main library you are using is header-only. For example, boost:asio[] is a header-only library, so it doesn't need to be compiled, but it depends on boost:system[] which does. If you use certain features of boost:asio[], then you will also need to build additional dependencies: boost:coroutine[] and boost:regex[].

The issue with building individual libraries is finding out the dependencies, and whether they need to be built too. Refer to the individual documentation for each library for this information, for example: https://www.boost.org/doc/libs/1_82_0/doc/html/boost_asio/using.html#boost_asio.using.dependencies[Boost.Asio Dependencies].

If you do not find dependency information in the documentation, you can also refer to the source code `#include` statements, and also the Jamfile located in the library's root folder contains build information.

Finally there is *Boostdep*, a tool developed by the Boost community that can report on dependencies within Boost. It's not part of the Boost distribution itself but can be found on GitHub at https://github.com/boostorg/boostdep[boostdep]. This tool analyzes the source code and provides accurate information about dependencies between libraries.

If you try to build a project, and have missed a dependency, you will of course get link errors, which should help you identify what additional libraries to pre-compile.

== Build with a Non-default Compiler

Using the `b2` build system, you can specify the compiler you want to use with the `toolset` option. For example, if you want to use the GNU Compiler Collection (GCC), you would specify `toolset=gcc`. If you want to use Clang, you would use `toolset=clang`. For example, to build the Boost libraries with gcc:

[source,bash]
----
./b2 toolset=gcc
----

If you want to use a specific _version_ of a compiler, you can specify it after the compiler name, separated by a dash. For example, to use GCC 7.3, you would use `toolset=gcc-7.3`:

[source,bash]
----
./b2 toolset=gcc-7.3
----

You can also specify the toolset option when you're building your application. This is done in a similar way, by passing `toolset=` to the `b2` command, as part of your build process:

[source,bash]
----
b2 toolset=clang
----

== Specify the Standard Library Implementation

When using Boost libraries in a project, you might choose to use `pass:[libc++]` or `pass:[libstdc++]`. These are two different standard library implementations that you can use with your pass:[C++] compiler.

. `pass:[libc++]` is the standard library implementation developed by the https://github.com/llvm/llvm-project[LLVM project]. It is the default library for the Clang compiler and is known for its performance and standards compliance. It's also designed to work well with the Clang static analyzer and other LLVM tools. One key feature of `pass:[libc++]` is that it supports deployment to older versions of macOS and iOS.

. `pass:[libstdc++]` is the GNU Standard Library, which comes as the default with the GCC compiler. It is a robust and mature library, supporting many pass:[C++] standards and extensions. It's used by a large number of projects and is available on a wide variety of systems.

You can specify which standard library you want to use by setting the appropriate flags in your build system. This is dependent on the compiler you're using.

If you're using the Clang compiler and you want to use `pass:[libc++]`, you can use the `-stdlib=libc++` compiler flag. For example:

[source,bash]
----
clang++ -stdlib=libc++ YOUR_FILE.cpp -lboost_system
----

If you're using GCC and you want to use  `pass:[libstdc++]`, you don't need to do anything specific because this is the default standard library for GCC. 

If you're using Clang and want to use  `pass:[libstdc++]`, you can use the `-stdlib=libstdc++` flag:

[source,bash]
----
clang++ -stdlib=libstdc++ your_file.cpp -lboost_system
----

When you're building the Boost libraries themselves, you can also specify the standard library to use with the `stdlib` option. The following command will build the Boost libraries using Clang with `pass:[libc++]`.

[source,bash]
----
./b2 toolset=clang stdlib=libc++
----

If you want to use the default library, then use `stdlib=native`, or simply do not enter this option.

== Specify Static or Dynamic Linking

The compiler options `link=static` and `link=dynamic` specify how the Boost libraries should be linked to your project. If you do not specify a type of linking and are building all the libraries, both a static and dynamic library is built. If you are building an individual library, then static is the default.

. If you specify `link=static` the linker takes the object code from the library and includes it in the executable file for the program. This leads to larger executables, but the resulting program is self-contained and does not require the library to be present on the system where the program is run. It can be beneficial when you want to avoid dependencies on shared libraries, particularly when you distribute your software to other systems.
+
[source,bash]
----
./b2 link=static
----
+
Apart from distributing applications, the other compelling reasons to use static linking are to avoid dependency or version conflicts, and perhaps improved performance, as the application doesn't need to load shared libraries at runtime.

. If you specify `link=dynamic` the linker only includes a small amount of code to locate and interface with the actual library code, which is kept in a separate file. This results in smaller executables and allows for library code to be shared between multiple programs. However, the resulting program requires that the shared library be available at both build time and run time. The build options `dynamic` and `shared` are synonymous.
+
[source,bash]
----
./b2 link=dynamic
./b2 link=shared
----

Not all Boost libraries need to be linked to your program. Many are "header-only", meaning you only need to include their headers in your source files and don't need to worry about linking, as there is nothing to link. 


== Integrate Build and Test

There are certainly advanced testing scenarios. Boost.Build can compile and run unit tests as part of the build process, making it easier to verify that your application behaves as expected. Refer to xref:testing-debugging.adoc[].

== Specify the Application Binary Interface

Building Boost with the old Application Binary Interface (ABI) refers to compiling the library with a flag to ensure backward compatibility with an older version of an ABI.

The ABI of a system is a specification that defines requirements for binary compatibility between applications and libraries that are built separately. It includes aspects such as calling conventions, byte order, and data structure alignment.

In the context of pass:[C++], this generally comes up with GCC 5.x and later versions, which introduced a new ABI to conform more closely with the pass:[C++11] and pass:[C++14] standards. This new ABI changed the implementations of `std::string` and `std::list`, among other things, which broke binary compatibility with older versions of these libraries. This means that code compiled with the new ABI may _not_ be binary-compatible with code compiled with the old ABI.

To build Boost with the old ABI, you'd pass in the `-D_GLIBCXX_USE_CXX11_ABI=0` flag. For example:

[source,bash]
----
./b2 toolset=gcc cxxflags="-D_GLIBCXX_USE_CXX11_ABI=0"
----

This command specifies the compiled Boost libraries are to be linked with code that was also compiled with the old ABI. Setting the flag to 1 will specify the new ABI, though of course this is the default and the flag is unnecessary.

Check compatibility with your entire toolchain and codebase when making decisions about which ABI to use. It's generally best to use the new ABI if all your code and dependencies support it.

== Build Boost with CMake

The recommended method of building the Boost libraries is with the `b2` tool. However, building with CMake is a supported alternative. Refer to the https://github.com/boostorg/cmake[Boost CMake support infrastructure] for full details, including information on general and library-specific configuration variables, testing after building with CMake, using Boost (or an individual Boost library) with the `add_subdirectory` command, and using Boost with the `FetchContent` command.

== See Also

For full details of Boost.Build, refer to the https://www.boost.org/build/doc/html/index.html[Boost.Build User Manual].

* https://github.com/boostorg/cmake[Boost CMake support infrastructure]
* xref:getting-started.adoc[]
* xref:resources.adoc[]
* xref:header-organization-compilation.adoc#toolset[Toolsets]
